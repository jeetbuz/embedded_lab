{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf470
{\fonttbl\f0\fnil\fcharset0 Monaco;}
{\colortbl;\red255\green255\blue255;\red127\green0\blue85;\red42\green0\blue255;\red0\green80\blue50;
\red100\green40\blue128;\red63\green127\blue95;}
\paperw11900\paperh16840\margl1440\margr1440\vieww25100\viewh14200\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\fs22 \cf2 #include\cf0  \cf3 <stdint.h>\cf0 \
\cf2 #include\cf0  \cf3 <stdbool.h>\cf0 \
\cf2 #include\cf0  \cf3 "inc/hw_memmap.h"\cf0 \
\cf2 #include\cf0  \cf3 "inc/hw_types.h"\cf0 \
\cf2 #include\cf0  \cf3 "driverlib/sysctl.h"\cf0 \
\cf2 #include\cf0  \cf3 "driverlib/gpio.h"\cf0 \
\cf2 #include\cf0  \cf3 "driverlib/debug.h"\cf0 \
\cf2 #include\cf0  \cf3 "driverlib/pwm.h"\cf0 \
\cf2 #include\cf0  \cf3 "driverlib/pin_map.h"\cf0 \
\cf2 #include\cf0  \cf3 "inc/hw_gpio.h"\cf0 \
\cf2 #include\cf0  \cf3 "driverlib/rom.h"\cf0 \
\cf2 #include\cf0  \cf3 "driverlib/timer.h"\cf0 \
\cf2 #include\cf0  \cf3 "driverlib/interrupt.h"\cf0 \
 \cf2 #include\cf0  \cf3 "inc/tm4c123gh6pm.h"\cf0 \
\
\cf2 extern\cf0  \cf4 uint8_t\cf0  count=1;\
\cf2 extern\cf0  \cf2 int\cf0  flag=0;\
\cf2 extern\cf0  \cf2 int\cf0  auto_mode=1;\
\cf2 extern\cf0  \cf2 int\cf0  sw1count=0;\
\cf2 extern\cf0  \cf2 int\cf0  set=0;\
\cf2 extern\cf0  \cf2 int\cf0  set1=0;\
\cf2 extern\cf0  \cf2 int\cf0  bright=254;\
\cf2 extern\cf0  \cf2 int\cf0  manual_mode=0;\
\cf2 extern\cf0  \cf2 int\cf0  flagm=0;\
\cf2 extern\cf0  \cf2 int\cf0  flaga=0;\
\cf2 extern\cf0  \cf2 int\cf0  flagb=0;\
\cf2 extern\cf0  \cf2 int\cf0  swcount=0;\
\cf2 extern\cf0  \cf2 int\cf0  flagj=0;\
\cf2 extern\cf0  \cf2 int\cf0  seth1=0;\
\cf2 extern\cf0  \cf2 int\cf0  setm1=0;\
\cf2 extern\cf0  \cf2 int\cf0  flagj1=0;\
\
\
\
\cf2 #define\cf0  LOCK_F (*((\cf2 volatile\cf0  \cf2 unsigned\cf0  \cf2 long\cf0  *)0x40025520))\
\cf2 #define\cf0  CR_F (*((\cf2 volatile\cf0  \cf2 unsigned\cf0  \cf2 long\cf0  *)0x40025524))\
\
\cf4 uint32_t\cf0  ui32Period;\
\
\cf2 #define\cf0  PWM_FREQUENCY 55\
\
\cf2 volatile\cf0  \cf4 uint32_t\cf0  ui32Load;\
\
\cf2 void\cf0  manual_mode1(\cf2 void\cf0 )\
\{   auto_mode=0;\
    \cf5 PWMPulseWidthSet\cf0 (PWM1_BASE, PWM_OUT_6, 5 * ui32Load / 1000);\
    \cf5 PWMPulseWidthSet\cf0 (PWM1_BASE, PWM_OUT_7, bright * ui32Load / 1000);\
\
        \cf5 PWMPulseWidthSet\cf0 (PWM1_BASE, PWM_OUT_5, 5 * ui32Load / 1000);\
\
\}\
\
\cf2 void\cf0  manual_mode2(\cf2 void\cf0 )\
\{auto_mode=0;\
\cf5 PWMPulseWidthSet\cf0 (PWM1_BASE, PWM_OUT_5, 5 * ui32Load / 1000);\
\cf5 PWMPulseWidthSet\cf0 (PWM1_BASE, PWM_OUT_7, 5 * ui32Load / 1000);\
\cf5 PWMPulseWidthSet\cf0 (PWM1_BASE, PWM_OUT_6, bright * ui32Load / 1000);\
\}\
\
\cf2 void\cf0  manual_mode3(\cf2 void\cf0 )\
\{auto_mode=0;\
\cf5 PWMPulseWidthSet\cf0 (PWM1_BASE, PWM_OUT_5, bright * ui32Load / 1000);\
\cf5 PWMPulseWidthSet\cf0 (PWM1_BASE, PWM_OUT_7, 5 * ui32Load / 1000);\
\cf5 PWMPulseWidthSet\cf0 (PWM1_BASE, PWM_OUT_6, 5 * ui32Load / 1000);\
\}\
\
\cf2 void\cf0  BlueInc(\cf2 volatile\cf0  \cf4 uint8_t\cf0  blue)\
\{ \cf2 while\cf0 (blue<254)\
\{\
    \cf2 if\cf0 (auto_mode==0)\
        \cf2 return\cf0 ;\
    \cf2 if\cf0 (flag!=2)\
\
    blue++;\
                \cf2 if\cf0  (blue > 254)\
                \{\
                    blue = 254;\
                \}\
    \cf5 SysCtlDelay\cf0 (count * 10000);\
    \cf5 PWMPulseWidthSet\cf0 (PWM1_BASE, PWM_OUT_6, blue * ui32Load / 1000);\
\
\
\}\
\}\
\
\cf2 void\cf0  RedInc(\cf2 volatile\cf0  \cf4 uint8_t\cf0  red)\
\{ \cf2 while\cf0 (red<254)\
\{\cf2 if\cf0 (auto_mode==0)\
    \cf2 return\cf0 ;\
    red++;\
                \cf2 if\cf0  (red > 254)\
                \{\
                    red = 254;\
                \}\
    \cf5 SysCtlDelay\cf0 (count * 10000);\
    \cf5 PWMPulseWidthSet\cf0 (PWM1_BASE, PWM_OUT_5, red * ui32Load / 1000);\
\
\
\}\
\}\
\
\
\cf2 void\cf0  GreenInc(\cf2 volatile\cf0  \cf4 uint8_t\cf0  green)\
\{ \cf2 while\cf0 (green<254)\
\{\cf2 if\cf0 (auto_mode==0)\
    \cf2 return\cf0 ;\
    green++;\
                \cf2 if\cf0  (green > 254)\
                \{\
                    green = 254;\
                \}\
    \cf5 SysCtlDelay\cf0 (count * 10000);\
    \cf5 PWMPulseWidthSet\cf0 (PWM1_BASE, PWM_OUT_7, green * ui32Load / 1000);\
\
\
\}\
\}\
\
\cf2 void\cf0  BlueDec(\cf2 volatile\cf0  \cf4 uint8_t\cf0  blue)\
\{ \cf2 while\cf0 (blue>10)\
\{\
    \cf2 if\cf0 (auto_mode==0)\
            \cf2 return\cf0 ;\
blue--;\
                \cf2 if\cf0  (blue < 10)\
                \{\
                    blue = 10;\
                \}\
    \cf5 SysCtlDelay\cf0 (count * 10000);\
    \cf5 PWMPulseWidthSet\cf0 (PWM1_BASE, PWM_OUT_6, blue * ui32Load / 1000);\
\
\
\}\
\}\
\
\cf2 void\cf0  RedDec(\cf2 volatile\cf0  \cf4 uint8_t\cf0  red)\
\{ \cf2 while\cf0 (red>10)\
\{\
    \cf2 if\cf0 (auto_mode==0)\
            \cf2 return\cf0 ;\
    red--;\
                \cf2 if\cf0  (red < 10)\
                \{\
                    red = 10;\
                \}\
    \cf5 SysCtlDelay\cf0 (count * 10000);\
    \cf5 PWMPulseWidthSet\cf0 (PWM1_BASE, PWM_OUT_5, red * ui32Load / 1000);\
\
\
\}\
\}\
\
\
\cf2 void\cf0  GreenDec(\cf2 volatile\cf0  \cf4 uint8_t\cf0  green)\
\{ \cf2 while\cf0 (green>10)\
\{\
    \cf2 if\cf0 (auto_mode==0)\
            \cf2 return\cf0 ;\
    green--;\
                \cf2 if\cf0  (green <10)\
                \{\
                    green = 10;\
                \}\
    \cf5 SysCtlDelay\cf0 (count * 10000);\
    \cf5 PWMPulseWidthSet\cf0 (PWM1_BASE, PWM_OUT_7, green * ui32Load / 1000);\
\
\
\}\
\}\
\
\
\
\
\cf2 int\cf0  main(\cf2 void\cf0 )\
\{\
    \cf2 volatile\cf0  \cf4 uint32_t\cf0  ui32PWMClock;\
    \cf2 volatile\cf0  \cf4 uint8_t\cf0  ui8Red,ui8Blue,ui8Green;\
    ui8Blue = ui8Red= ui8Green=1;\
    \cf2 volatile\cf0  \cf4 uint8_t\cf0  ui8Adjust;\
    ui8Adjust = 1;\
\
    \cf5 SysCtlClockSet\cf0 (SYSCTL_SYSDIV_5|SYSCTL_USE_PLL|SYSCTL_OSC_MAIN|SYSCTL_XTAL_16MHZ);\
   \cf5 SysCtlPWMClockSet\cf0 (SYSCTL_PWMDIV_64);\
    \cf5 SysCtlPeripheralEnable\cf0 (SYSCTL_PERIPH_PWM1);\
    \cf5 SysCtlPeripheralEnable\cf0 (SYSCTL_PERIPH_GPIOF);\
    LOCK_F=0x4C4F434BU;\
    CR_F=GPIO_PIN_0|GPIO_PIN_4;\
    \cf5 GPIOPinTypeGPIOOutput\cf0 (GPIO_PORTF_BASE, GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3);\
    \cf5 GPIOPinTypeGPIOInput\cf0 (GPIO_PORTF_BASE,GPIO_PIN_0|GPIO_PIN_4);\
    \cf5 GPIOPadConfigSet\cf0 (GPIO_PORTF_BASE,GPIO_PIN_0|GPIO_PIN_4,GPIO_STRENGTH_2MA,GPIO_PIN_TYPE_STD_WPU);\
    \cf6 // Turn on the LED\cf0 \
    \cf5 SysCtlPeripheralEnable\cf0 (SYSCTL_PERIPH_TIMER0);\
    \cf5 TimerConfigure\cf0 (TIMER0_BASE, TIMER_CFG_PERIODIC);\
\
    ui32Period = (\cf5 SysCtlClockGet\cf0 () / 10) / 2;\
    \cf5 TimerLoadSet\cf0 (TIMER0_BASE, TIMER_A, ui32Period -1);\
\
    \cf5 IntEnable\cf0 (INT_TIMER0A);\
    \cf5 TimerIntEnable\cf0 (TIMER0_BASE, TIMER_TIMA_TIMEOUT);\
    \cf5 IntMasterEnable\cf0 ();\
\
     \cf5 TimerEnable\cf0 (TIMER0_BASE, TIMER_A);\
    \cf5 GPIOPinConfigure\cf0 (GPIO_PF1_M1PWM5);\
    \cf5 GPIOPinConfigure\cf0 (GPIO_PF2_M1PWM6);\
    \cf5 GPIOPinConfigure\cf0 (GPIO_PF3_M1PWM7);\
    \cf5 GPIOPinTypePWM\cf0 (GPIO_PORTF_BASE, GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_3);\
\cf6 //    GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3);\cf0 \
\
    HWREG(GPIO_PORTF_BASE + GPIO_O_LOCK) = GPIO_LOCK_KEY;\
    HWREG(GPIO_PORTF_BASE + GPIO_O_CR) |= 0x01;\
    HWREG(GPIO_PORTF_BASE + GPIO_O_LOCK) = 0;\
\
    ui32PWMClock = \cf5 SysCtlClockGet\cf0 () / 64;\
    ui32Load = (ui32PWMClock / PWM_FREQUENCY) - 1;\
    \cf5 PWMGenConfigure\cf0 (PWM1_BASE, PWM_GEN_2, PWM_GEN_MODE_DOWN );\
    \cf5 PWMGenConfigure\cf0 (PWM1_BASE, PWM_GEN_3, PWM_GEN_MODE_DOWN );\
    \cf5 PWMGenPeriodSet\cf0 (PWM1_BASE, PWM_GEN_2, ui32Load);\
    \cf5 PWMGenPeriodSet\cf0 (PWM1_BASE, PWM_GEN_3, ui32Load);\
\
    \cf5 PWMPulseWidthSet\cf0 (PWM1_BASE, PWM_OUT_5, ui8Red * ui32Load / 1000);\
    \cf5 PWMPulseWidthSet\cf0 (PWM1_BASE, PWM_OUT_6, ui8Blue * ui32Load / 1000);\
    \cf5 PWMPulseWidthSet\cf0 (PWM1_BASE, PWM_OUT_7, ui8Green * ui32Load / 1000);\
\
    \cf5 PWMGenEnable\cf0 (PWM1_BASE, PWM_GEN_3);\
    \cf5 PWMGenEnable\cf0 (PWM1_BASE, PWM_GEN_2);\
\
    \cf5 PWMOutputState\cf0 (PWM1_BASE, PWM_OUT_5_BIT | PWM_OUT_6_BIT | PWM_OUT_7_BIT, true);\
\
    \cf6 /// INTERRUPT SETUP\cf0 \
\
 \cf6 //   SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);\cf0 \
\
\
\
\
    \cf2 while\cf0 (1)\
    \{\
       \cf5 SysCtlDelay\cf0 (100000);\
        \cf2 if\cf0 (auto_mode==1)\
        \{\
           BlueInc(10);\
           RedInc(10);\
           BlueDec(255);\
           GreenInc(10);\
           RedDec(255);\
           BlueInc(10);\
           GreenDec(255);\
           BlueDec(255);\
        \}\
\
        \cf2 if\cf0 (auto_mode==0)\
        \{   sw1count=0;\
            \cf2 if\cf0 (manual_mode==1)\
                manual_mode1();\
            \cf2 if\cf0 (manual_mode==2)\
                manual_mode2();\
            \cf2 if\cf0 (manual_mode==3)\
                manual_mode3();\
        \}\
\
\
\
    \}\
\
\}\
\
\
\cf2 unsigned\cf0  \cf2 char\cf0  DetectKeyPress(\cf2 void\cf0 )\
\{\
\
 \cf6 //         Auto Mode delay control\cf0 \
    \cf2 if\cf0 ((flaga==0)&&((auto_mode==1)&&(!(\cf5 GPIOPinRead\cf0 (GPIO_PORTF_BASE, GPIO_PIN_0)))))\
           \{\
               \cf2 if\cf0 (set1==1)\
               \{\
\
                   count=count+1;\
                       \cf2 if\cf0 (count>100)\
                           count=100;\
\
                   set1=0;\
                   flaga=3;\
               \}\
               set1=1;\
           \}\
           \cf2 else\cf0  \cf2 if\cf0 ((auto_mode==1)&&(flaga==0)&&(set1==1)&&(\cf5 GPIOPinRead\cf0 (GPIO_PORTF_BASE, GPIO_PIN_0)))\
           \{\
               set1=0;\
           \}\
           \cf2 else\cf0  \cf2 if\cf0 ((auto_mode==1)&&(flaga==3)&&(\cf5 GPIOPinRead\cf0 (GPIO_PORTF_BASE, GPIO_PIN_0)))\
           \{\
               set1=0;\
               flaga=0;\
           \}\
\
    \cf2 if\cf0 ((flagb==0)&&((auto_mode==1)&&(!(\cf5 GPIOPinRead\cf0 (GPIO_PORTF_BASE, GPIO_PIN_4)))))\
               \{\
                   \cf2 if\cf0 (set==1)\
                   \{\
                       count=count-1;\
                               \cf2 if\cf0 (count<=1)\
                                   count=1;\
\
                       set=0;\
                       flagb=4;\
                   \}\
                   set=1;\
               \}\
               \cf2 else\cf0  \cf2 if\cf0 ((auto_mode==1)&&(flagb==0)&&(set==1)&&(\cf5 GPIOPinRead\cf0 (GPIO_PORTF_BASE, GPIO_PIN_4)))\
               \{\
                   set=0;\
               \}\
               \cf2 else\cf0  \cf2 if\cf0 ((auto_mode==1)&&(flagb==4)&&(\cf5 GPIOPinRead\cf0 (GPIO_PORTF_BASE, GPIO_PIN_4)))\
               \{\
                   set=0;\
                   flagb=0;\
               \}\
\
    \cf6 //      Manual mode   case 1 and case 2\cf0 \
\
    \cf2 if\cf0 ((auto_mode==1)&&(!\cf5 GPIOPinRead\cf0 (GPIO_PORTF_BASE, GPIO_PIN_0)))\
                   \{\
                    \cf2 if\cf0 (!(\cf5 GPIOPinRead\cf0 (GPIO_PORTF_BASE, GPIO_PIN_4)))\
\
                   \{    set=0;\
                \cf6 //   sw1count=0;\cf0 \
                \cf6 //   swcount=0;\cf0 \
\
\
                        \cf2 while\cf0 (!\cf5 GPIOPinRead\cf0 (GPIO_PORTF_BASE, GPIO_PIN_0))\
                   \{\
\
                   \cf2 if\cf0 (!(\cf5 GPIOPinRead\cf0 (GPIO_PORTF_BASE, GPIO_PIN_4)))\
                   \{\
               swcount++;\
                   \}\
\
                    \cf2 if\cf0 ((flagm==0)&&(!(\cf5 GPIOPinRead\cf0 (GPIO_PORTF_BASE, GPIO_PIN_4))))\
                   \{\
                        \cf2 if\cf0 (set==1)\
                        \{set =0;\
                        flagm=1;\
                       sw1count++;\
                        \}\
                       set=1;\
                   \}\
                   \cf2 else\cf0  \cf2 if\cf0 ((set==1)&&(\cf5 GPIOPinRead\cf0 (GPIO_PORTF_BASE, GPIO_PIN_4)))\
                   \{\
                       set=0;\
                   \}\
                   \cf2 else\cf0  \cf2 if\cf0 ((flagm==1)&&(\cf5 GPIOPinRead\cf0 (GPIO_PORTF_BASE, GPIO_PIN_4)))\
                   \{   set=0;\
                       flagm=0;\
                   \}\
                   \}\
                   \}\
                   \}\
\
\
\
\
    \cf2 if\cf0 (sw1count>=3)\
            \{   swcount=0;\
                set=0;\
                auto_mode=0;\
                manual_mode=3;\
            \}\
\
        \cf2 if\cf0 (sw1count==2)\
        \{   sw1count=0;\
            set=0;\
            auto_mode=0;\
            manual_mode=2;\
        \}\
\
\
         \cf2 if\cf0 (sw1count==1)\
         \{  sw1count=0;\
             set=0;\
             auto_mode=0;\
             manual_mode=1;\
\
         \}\
\
 \cf6 ////   manual mode brightness control\cf0 \
\
\
         \cf2 if\cf0 ((flagj==0)&&((auto_mode==0)&&(!(\cf5 GPIOPinRead\cf0 (GPIO_PORTF_BASE, GPIO_PIN_0)))))\
                    \{\
                        \cf2 if\cf0 (setm1==1)\
                        \{\
\
                            bright=bright+20;\
                                \cf2 if\cf0 (bright>254)\
                                    bright=254;\
\
                            setm1=0;\
                            flagj=3;\
                        \}\
                        setm1=1;\
                    \}\
                    \cf2 else\cf0  \cf2 if\cf0 ((auto_mode==0)&&(flagj==0)&&(setm1==1)&&(\cf5 GPIOPinRead\cf0 (GPIO_PORTF_BASE, GPIO_PIN_0)))\
                    \{\
                        setm1=0;\
                    \}\
                    \cf2 else\cf0  \cf2 if\cf0 ((auto_mode==0)&&(flagj==3)&&(\cf5 GPIOPinRead\cf0 (GPIO_PORTF_BASE, GPIO_PIN_0)))\
                    \{\
                        setm1=0;\
                        flagj=0;\
                    \}\
\
             \cf2 if\cf0 ((flagj1==0)&&((auto_mode==0)&&(!(\cf5 GPIOPinRead\cf0 (GPIO_PORTF_BASE, GPIO_PIN_4)))))\
                        \{\
                            \cf2 if\cf0 (seth1==1)\
                            \{\
                                bright=bright-20;\
                                        \cf2 if\cf0 (bright<=1)\
                                            bright=1;\
\
                                seth1=0;\
                                flagj1=4;\
                            \}\
                            seth1=1;\
                        \}\
                        \cf2 else\cf0  \cf2 if\cf0 ((auto_mode==0)&&(flagj1==0)&&(seth1==1)&&(\cf5 GPIOPinRead\cf0 (GPIO_PORTF_BASE, GPIO_PIN_4)))\
                        \{\
                            seth1=0;\
                        \}\
                        \cf2 else\cf0  \cf2 if\cf0 ((auto_mode==0)&&(flagj1==4)&&(\cf5 GPIOPinRead\cf0 (GPIO_PORTF_BASE, GPIO_PIN_4)))\
                        \{\
                            seth1=0;\
                            flagj1=0;\
                        \}\
\
\
\
\
\
\
\
            \cf2 return\cf0  flag;\
\}\
\
\cf2 int\cf0  f;\
\cf2 void\cf0  Timer0Handler(\cf2 void\cf0 )\
       \{\
        \cf6 // Clear the timer interrupt\cf0 \
        \cf5 TimerIntClear\cf0 (TIMER0_BASE, TIMER_TIMA_TIMEOUT);\
        \cf6 // Read the current state of the GPIO pin and\cf0 \
        \cf6 // write back the opposite state\cf0 \
        f=DetectKeyPress();\
\
        \}\
}